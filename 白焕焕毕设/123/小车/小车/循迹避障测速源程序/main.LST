C51 COMPILER V9.60.0.0   MAIN                                                              05/03/2020 22:50:24 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: F:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND

line level    source

   1          
   2          
   3          /*
   4          *************************************************************************
   5          *产品名称：超声波避障寻迹小车
   6          *硬件平台：焊好的模块
   7          *显示模块：液晶1602
   8          *输入模块：暂无
   9          *实现的功能：寻迹小车加避障功能  ,  当前面有障碍物，则小车向右转
  10          *操作描述：上电即可
  11          *接口说明：----------------------------------------- 
  12          *当前的缺陷：  
  13          *待改进的地方：暂无
  14          *遇到的问题：―――――――――――――――――――――――――――――― 
  15          *开发平台：KELL_MDK4.7
  16          
  17          *备    注： s = t * v;   v = s / t; 
  18          *
  19          *第一次修改时间：2014.4.11 
  20          *第一次修改内容：增加有前面距离小于20CM就右转的功能,测试的现象是刚好右转了180度
  21          *
  22          *第二次修改时间：
  23          *第二次修改内容：
  24          *************************************************************************
  25          */
  26          
  27          #include "std_for_wym.h"
  28          #include "eepom52.h"//
  29          #define L 3
  30          #define R 4
  31          
  32          /***************************
  33                        直径6.5cm
  34                                    周长：3.14*6.5 = 20.4cm        小车走一圈就是 20.4cm
  35                                           // 2.55 = 20.4 / 8 = 2.55 算出每一个脉冲的轮子走了多少距离
  36          *****************************/
  37          
  38          // long lSpeedCount = 0;
  39          // int iSpeedCount = 0;
  40          // float fSpeed = 0;
  41          
  42          /********************寻迹模块IO口定义*********************************/
  43          sbit xun_ll = P0^4;       //从左到右第1个
  44          sbit xun_l  = P0^3;       //从左到右第2个
  45          sbit xun_z  = P0^2;       //从左到右第3个
  46          sbit xun_r  = P0^1;       //从左到右第4个
  47          sbit xun_rr = P0^0;       //从左到右第5个
  48          
  49          /********************LN298电机驱动IO口定义*********************************/
  50          sbit qu_ll = P2^0;         //左边电机控制IN1
  51          sbit qu_zl = P2^1;         //左边电机控制IN2
  52          sbit qu_zr = P2^2;         //右边电机控制IN1
  53          sbit qu_rr = P2^3;         //右边电机控制IN2
  54          
  55          
C51 COMPILER V9.60.0.0   MAIN                                                              05/03/2020 22:50:24 PAGE 2   

  56          
  57          /***********************小车前进函数************************/
  58          void go()
  59          {
  60   1              qu_ll = 1;  
  61   1              qu_zl = 0; 
  62   1              qu_zr = 0; 
  63   1              qu_rr = 1;      
  64   1      }
  65          
  66          // /***********************小车后退函数************************/
  67          // void back()
  68          // {
  69          //      qu_ll = 0;  
  70          //      qu_zl = 1; 
  71          //      qu_zr = 1; 
  72          //      qu_rr = 0;      
  73          // }
  74          
  75          /***********************小车左转函数 只有一个轮子动************************/
  76          void left()
  77          {
  78   1              qu_ll = 0;  
  79   1              qu_zl = 0; 
  80   1              qu_zr = 0; 
  81   1              qu_rr = 1;      
  82   1      }
  83          
  84          /***********************小车左转函数 左边轮子后退 右边轮子前进************************/
  85          void left_s()
  86          {
  87   1              qu_ll = 0;  
  88   1              qu_zl = 1; 
  89   1              qu_zr = 0; 
  90   1              qu_rr = 1;      
  91   1      }
  92          
  93          /***********************小车停下函数************************/
  94          void stop()
  95          {
  96   1              qu_ll = 0;  
  97   1              qu_zl = 0; 
  98   1              qu_zr = 0; 
  99   1              qu_rr = 0;
 100   1      }
 101          
 102          /***********************小车右转函数 只有一个轮子动************************/
 103          void right()
 104          {
 105   1              qu_ll = 1;  
 106   1              qu_zl = 0; 
 107   1              qu_zr = 0; 
 108   1              qu_rr = 0;      
 109   1      }
 110          
 111          /***********************小车右转函数 左边轮子前进 右边轮子后退************************/
 112          void right_s()
 113          {
 114   1              qu_ll = 1;  
 115   1              qu_zl = 0; 
 116   1              qu_zr = 1; 
 117   1              qu_rr = 0;      
C51 COMPILER V9.60.0.0   MAIN                                                              05/03/2020 22:50:24 PAGE 3   

 118   1      }
 119          
 120          
 121          void che_90_180_break(uchar dat)
 122          {       
 123   1              uchar i_z = 0;
 124   1              while(1)                          //循环等待中间寻迹传感器到黑线上
 125   1              {       
 126   2                  if(xun_z == 0)        //如果中间那寻迹传感器到了黑线上，要让小车停下来前进了
 127   2                      {
 128   3                              i_z++;        //消去干扰
 129   3                              if(i_z >= 10) //10次之后就确定寻迹模块的中间传感器到黑线上了
 130   3                              {
 131   4                                      if(dat == L)   //如果是左转90度就让右转的方法制动
 132   4                                              right_s();      
 133   4                                      else 
 134   4                                              left_s();  //如果是右转90度就让左转的方法制动
 135   4                                      DelayMs(50);
 136   4                                      go();            
 137   4                                      break;             //break退出while(1)这个死循环
 138   4                              }
 139   3                      }
 140   2                      else       //没有在黑钱上就给i_z变量清零
 141   2                      {
 142   3                              i_z = 0;
 143   3                      }       
 144   2              }
 145   1      }
 146          
 147          /***********************小车左转90度************************/
 148          void left_s_90_while()          //小车向左转90度
 149          {
 150   1              go();                                   //前进一小会让小车转90度时刚好让黑线在小车的中间                                  
 151   1              DelayMs(120);
 152   1              left_s();                               //左转90度注意这个延时不能太长  只要能让寻迹模块中间的传感离开黑线就好
 153   1              DelayMs(180);
 154   1              che_90_180_break(L);    
 155   1      }
 156          
 157          /***********************小车向右转90度************************/
 158          void right_s_90_while()     //
 159          {
 160   1              go();                                   //前进一小会让小车转90度时刚好让黑线在小车的中间                                  
 161   1              DelayMs(120);
 162   1              right_s();                              //左转90度注意这个延时不能太长  只要能让寻迹模块中间的传感离开黑线就好
 163   1              DelayMs(180);
 164   1              che_90_180_break(R);    
 165   1      }
 166          
 167          
 168          
 169          
 170          // 白线为 1   黑线为 0
 171          void xunnji()
 172          {
 173   1              if((xun_ll==1) && (xun_l==1) && (xun_z==0) && (xun_r==1) && (xun_rr==1))
 174   1              {
 175   2                      go();     //小车前进
 176   2              }               
 177   1              if((xun_ll==0) && (xun_l==0) && (xun_z==0) && (xun_r==0) && (xun_rr==0)) 
 178   1              {       
 179   2                      stop();                                 
C51 COMPILER V9.60.0.0   MAIN                                                              05/03/2020 22:50:24 PAGE 4   

 180   2              }
 181   1              
 182   1              if(((xun_ll==1) && (xun_l==1) && (xun_z==0) && (xun_r==0) && (xun_rr==1)) ||
 183   1                 ((xun_ll==1) && (xun_l==1) && (xun_z==1) && (xun_r==0) && (xun_rr==1)) ||
 184   1                 ((xun_ll==1) && (xun_l==1) && (xun_z==1) && (xun_r==0) && (xun_rr==0)) ||
 185   1                 ((xun_ll==1) && (xun_l==1) && (xun_z==1) && (xun_r==1) && (xun_rr==0)))         
 186   1              {
 187   2                      right();
 188   2              }
 189   1              if(((xun_ll==1) && (xun_l==0) && (xun_z==0) && (xun_r==1) && (xun_rr==1)) ||
 190   1                 ((xun_ll==1) && (xun_l==0) && (xun_z==1) && (xun_r==1) && (xun_rr==1)) ||
 191   1                 ((xun_ll==0) && (xun_l==0) && (xun_z==1) && (xun_r==1) && (xun_rr==1)) ||
 192   1                 ((xun_ll==0) && (xun_l==1) && (xun_z==1) && (xun_r==1) && (xun_rr==1)))         
 193   1              {
 194   2                      left();
 195   2              }
 196   1              if((xun_ll==1) && (xun_z==0) && (xun_r==0) && (xun_rr==0))         
 197   1              {               
 198   2                      go();                                                           
 199   2                      DelayMs(1);
 200   2                      if((xun_ll==1) && (xun_z==0) && (xun_r==0) && (xun_rr==0))       
 201   2                      {       
 202   3                              right_s_90_while();
 203   3                      }
 204   2              }       
 205   1              if((xun_ll==0) && (xun_l==0)  && (xun_z==0) && (xun_rr==1))        
 206   1              {
 207   2                      go();
 208   2                      DelayMs(1);
 209   2                      if((xun_ll==0) && (xun_l==0)  && (xun_z==0) && (xun_rr==1))      
 210   2                      {
 211   3                              left_s_90_while();
 212   3                      }
 213   2              }
 214   1      } 
 215          /************************************************
 216          ** 函数名称 ： void int0_init(void)
 217          ** 函数功能 ： 外部中断0初始化
 218          ************************************************/
 219          void int0_init(void)
 220          {
 221   1              IT0=1;      //下降沿触发
 222   1              EX0=1;          //中断标志位置1
 223   1              EA=1;           //打开总中断
 224   1      }
 225          uchar count_v=0,v=0;
 226          void main(void)
 227          {
 228   1              uchar speed_v[16]={"V=00cm/sL=000.0m"};
 229   1              uint S;
 230   1              int Dis = 50;                                           
 231   1              uchar i=0;
 232   1              InitTimer();    //定时器初始化
 233   1              Init_1602();    //液晶初始化
 234   1              CsbInit();              //超声波初始化
 235   1              int0_init();
 236   1              while(1)
 237   1              {
 238   2                      xunnji();        //循迹函数
 239   2                      if(time_1000ms)
 240   2                      {       
 241   3                              time_1000ms = 0 ;
C51 COMPILER V9.60.0.0   MAIN                                                              05/03/2020 22:50:24 PAGE 5   

 242   3                              v=count_v*2.55;
 243   3                              count_v=0;
 244   3                              S+=v;
 245   3      
 246   3                              xunnji();        //循迹函数
 247   3      
 248   3                              Dis = GetDis();   //读出距离
 249   3                              Lcd1602Printf(2,3,"Dis = %4.2f",Dis/100.0);
 250   3      
 251   3                              xunnji();        //循迹函数
 252   3      
 253   3                              if(Dis < 24)      //壁障距离
 254   3                              {
 255   4                                      right_s();        //右转
 256   4                                      DelayMs(500);
 257   4                              }
 258   3      
 259   3                              xunnji();        //循迹函数
 260   3      
 261   3                              speed_v[2]=v/10+0x30;
 262   3                              speed_v[3]=v%10+0x30;
 263   3                              xunnji();
 264   3                              speed_v[10]=S/10000+0x30;
 265   3                              speed_v[11]=S/1000%10+0x30;
 266   3                              speed_v[12]=S/100%10+0x30;
 267   3                              speed_v[14]=S/10%10+0x30;
 268   3      
 269   3                              xunnji();        //循迹函数
 270   3      
 271   3                              Lcd1602Printf(1,0,speed_v);
 272   3      
 273   3                              xunnji();        //循迹函数
 274   3                      }       
 275   2              }
 276   1      }
 277          /************************************************
 278          ** 函数名称 ： void int0() interrupt 0
 279          ** 函数功能 ： 外部0中断函数
 280          ************************************************/
 281          void int0() interrupt 0
 282          {       
 283   1              count_v++;      
 284   1      }
 285          
 286          
 287          
 288          
 289          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    802    ----
   CONSTANT SIZE    =     28    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      2      23
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
