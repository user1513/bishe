#include<reg52.h>

#define uchar unsigned char
#define uint unsigned int

sbit lcdrs=P0^0;		   //LCD RS引脚声明
sbit lcdrw=P0^1;		   //LCD RW引脚声明
sbit lcden=P0^2;		   //LCD E引脚声明

sbit addr_a=P1^2;		   //多路选择器选择地址a
sbit addr_b=P1^3;		   //多路选择器选择地址b

sbit pulse_a=P3^2;		  //脉冲输入引脚
sbit pulse_b=P3^3;		  //脉冲输入引脚

sfr T2MOD  = 0x0C9;		 //定时器2tmod寄存器声明


uchar flag_phase = 0;	 
uchar flag_freq = 0;


//0~360°的余弦值扩大10000倍，方便处理
int code cos_table[361]= {
10000,9998,9993,9986,9975,9961,9945,9925,9902,9876,9848,9816,9781,9743,9702,9659,9612,9563,9510,9455,9396,9335,9271,9205,9135,9063,8987,8910,8829,8746,
8660,8571,8480,8386,8290,8191,8090,7986,7880,7771,7660,7547,7431,7313,7193,7071,6946,6819,6691,6560,6427,6293,6156,6018,5877,5735,5591,5446,5299,
5150,5000,4848,4694,4539,4383,4226,4067,3907,3746,3583,3420,3255,3090,2923,2756,2588,2419,2249,2079,1908,1736,1564,1391,1218,1045,871,697,523,
348,174,0,-174,-348,-523,-697,-871,-1045,-1218,-1391,-1564,-1736,-1908,-2079,-2249,-2419,-2588,-2756,-2923,-3090,-3255,-3420,-3583,-3746,-3907,-4067,-4226,-4383,
-4539,-4694,-4848,-4999,-5150,-5299,-5446,-5591,-5735,-5877,-6018,-6156,-6293,-6427,-6560,-6691,-6819,-6946,-7071,-7193,-7313,-7431,-7547,-7660,-7771,-7880,-7986,-8090,-8191,
-8290,-8386,-8480,-8571,-8660,-8746,-8829,-8910,-8987,-9063,-9135,-9205,-9271,-9335,-9396,-9455,-9510,-9563,-9612,-9659,-9702,-9743,-9781,-9816,-9848,-9876,-9902,-9925,-9945,
-9961,-9975,-9986,-9993,-9998,-10000,-9998,-9993,-9986,-9975,-9961,-9945,-9925,-9902,-9876,-9848,-9816,-9781,-9743,-9702,-9659,-9612,-9563,-9510,-9455,-9396,-9335,-9271,-9205,
-9135,-9063,-8987,-8910,-8829,-8746,-8660,-8571,-8480,-8386,-8290,-8191,-8090,-7986,-7880,-7771,-7660,-7547,-7431,-7313,-7193,-7071,-6946,-6819,-6691,-6560,-6427,-6293,-6156,
-6018,-5877,-5735,-5591,-5446,-5299,-5150,-5000,-4848,-4694,-4539,-4383,-4226,-4067,-3907,-3746,-3583,-3420,-3255,-3090,-2923,-2756,-2588,-2419,-2249,-2079,-1908,-1736,-1564,
-1391,-1218,-1045,-871,-697,-523,-348,-174,0,174,348,523,697,871,1045,1218,1391,1564,1736,1908,2079,2249,2419,2588,2756,2923,3090,3255,3420,
3583,3746,3907,4067,4226,4383,4539,4694,4848,4999,5150,5299,5446,5591,5735,5877,6018,6156,6293,6427,6560,6691,6819,6946,7071,7193,7313,7431,7547,
7660,7771,7880,7986,8090,8191,8290,8386,8480,8571,8660,8746,8829,8910,8987,9063,9135,9205,9271,9335,9396,9455,9510,9563,9612,9659,9702,9743,9781,
9816,9848,9876,9902,9925,9945,9961,9975,9986,9993,9998,10000
};

uint freqs;
volatile uint phase;

void delay(uint z)					//延时函数
{									
	uint i,j;
	for(i=110;i>0;i--)				//进行n*110次的控制零延时
		for(j=z;j>0;j--);
}
void write_com(uchar com)						   //对LCD1602写指令操作，时序可看芯片手册
{

	lcdrs=0;
	P2=com;
	delay(5);
	lcden=1;
	delay(5);
	lcden=0;
}
void write_data(uchar dat)						 //对LCD1602写数据操作，时序可看芯片手册
{
	lcdrs=1;
	P2=dat;
	delay(5);
	lcden=1;
	delay(5);
	lcden=0;
}

void lcd_init()								  //初始化LCD，并且光标从第一行第一个位置开始写
{
	lcden=0;
	lcdrw = 0 ;
	write_com(0x38);
	write_com(0x0c);
	write_com(0x06);
	write_com(0x01);
	write_com(0x80);

}
void display_res(uchar channle_num, uint pos, uint d_tab, uint angle_cos)						//根据输入的通道，显示的位置 ，显示最终相位差和功率
{
	uchar a3 = 0;
	uchar a,b,c,d,e = 0;
	a = d_tab / 10000;						  //求出各个位上的值
	b = d_tab / 1000 %10;					  //例如12345 => 1 2 3 4 5
	c = d_tab /100 %10;
	d = d_tab /10 % 10;
	e = d_tab % 10;;
	write_com(0x80+pos); 					//初始化LCD光标位置

	write_data(0x30+ channle_num);			//写入更新的通道数
	write_data(':');						//写个冒号
	if(a == 0)								//如果首位为0，则空着
		write_data(' ');
	else		
		write_data(0x30+a);					 //如果第二位为0，则空着
	if(a== 0 & b ==0)
		write_data(' ');
	else
		write_data(0x30+b);
	write_data(0x30+c);					   //证书部分更新完毕
	write_data('.');					   //添加小数点
	write_data(0x30+d);					   //显示小数部分
	write_data(0x30+e);

	b = angle_cos / 1000;				   //求出各个位上的值
	c = angle_cos /100 %10;				   //例如1234 => 1 2 3 4
	d = angle_cos /10 % 10;
	e = angle_cos % 10;


	write_com(0x80 + 0x42);				 //lcd光标从第二行第三位置开始写
	write_data('0');					 //由于余弦都是小数，整数部分固定0
	write_data('.');					 //添加小数点
	write_data(0x30+b);					 //显示4位小数部分
	write_data(0x30+c);
	write_data(0x30+d);
	write_data(0x30+e);
	
	
	write_com(0x02);					 //显示完毕
}

void timer_ExInt_init()					 //定时器初始化
{	
//	EX0 = 1;
//	EX1 = 1;
//	IT0 = 1;
//	IT1 = 1;
										  
	TMOD = 0x10;					   //定时器2工作在方式1

	TH1 = 0;						  //填初值0.从0开始计数
	TL1 = 0;

	TR1 = 0;						   //关闭定时器
	EA=1;					  								  //开启中断开关可有可无
}


void uart_init()
{
	SCON=0x40;
	PCON = 0X00;				//波特率不加倍
	REN=1;						//发送接收是能
	T2MOD = 0X01;
	T2CON = 0X30;			   	//设置T2位波特率时钟
	RCAP2H = 0xff;			   	//65536-11059200/32×9600
	RCAP2L = 0xd9;			  	//初始化计数值 11.0592Mhz 9600波特率
	TH2 = 0xff;				  	//初始化计数值 11.0592Mhz 9600波特率
	TL2 = 0xd9;				  
	SM0=0;					  	//串口模式8为数据为，1位停止位
	SM1=1;					  	//串口模式8为数据为，1位停止位
	TR2=1;					  	//定时器2开始计数
	TI=0;					  	//清除中断标志位
}



void send_char(uchar dat)		//发送一个字节数据
{
	SBUF=dat;					//发送数据
	while(!TI);				    //等待发送是否完成
	TI=0;
}

void send_num(uint num)		//发送一个字节数据
{
	int i;
	uchar tab[2] = {0};

	tab[0] = (num & 0xff00) >> 8;	   //发送功率数据，扩大10000倍的，方便上位机处理，高位在前，低位在后
	tab[1] = (num & 0x00ff);
		 
	for(i=0;i<2;i++)			//将所有数据发送出去
	{
		send_char(tab[i]);
	}
}


void main()
{
	uint Ch_num = 0;
	float ratio = 0;
	float angle = 0;
	uint uart_str[6] = {0};
	char uart_num = 0;
	uint anle_100 = 0;
	uint angle_int = 0;
	addr_b = 0;
	addr_a = 0;
	lcd_init();
	timer_ExInt_init();
	uart_init();
	while(1)
	{
		while(pulse_a);						   //检测脉冲1的上升沿
		while(!pulse_a);
		TR1 = 1;						   		//开定时器计数
		while(pulse_b);							//检测脉冲2的上升沿
		while(!pulse_b);						
		TR1 = 0;								//关闭定时器1
		phase = (TH1 << 8) + TL1;				//记录计数值，此为相位差值
		TR1 = 1;								//开定时器1,
		while(pulse_a);							//检测脉冲1的上升沿
		while(!pulse_a);
		TR1 = 0;								 //定时器1关闭
		freqs = (TH1 << 8) + TL1 + 15;			 //记录定时器的值，加上一个误差修正
		TH1 = 0;								 //定时器计数设初值
		TL1 = 0;								 //定时器计数设初值
//		display_res(0,phase);
//		display_res(0x40,freqs);

		ratio = (float)phase / (float)freqs;	  //求出相位差的比例
		angle = 360 * ratio;					  //求出相位差的的角度
		anle_100 = angle * 100;					  //角度扩大100倍用于LCD显示小数点
		angle_int = (uint)angle;				  //获得整数的角度值
		display_res(Ch_num,0,anle_100, cos_table[angle_int]);	//调用显示函数，显示通道，位置，角度，以及功率值
		uart_str[Ch_num * 2] = anle_100 ;	  	  //存入角度值
		uart_str[Ch_num * 2 + 1] = 	cos_table[angle_int];//存入功率因数
		send_num(0X55AA);
		for(uart_num = 0; uart_num < 6; uart_num++)
		{
			send_num(uart_str[uart_num]);
		}
		//send_num(cos_table[angle_int]);	 			//发送功率的扩大10000倍值给上位机
		Ch_num = Ch_num + 1;						//通道数+1
		if(Ch_num == 3)								//一共三个通道，计数到三清零
			Ch_num = 0;
		addr_a = Ch_num & 0x1;						//通道数进行地址译码
		addr_b = Ch_num & 0x2;						//通道数进行地址译码
		delay(50);									//延时一会进行下次测量
	}	
}
